=================
Core Usage Guide
=================

This section details use of SQLAlchemy-FoundationDB at the level of
SQLAlchemy Core.   ORM users should read this section first as most of
what's here applies to ORM use as well.

Prerequisites / Installation
=============================

SQLAlchemy-FoundationDB depends on:

* `fdb-sql <https://github.com/FoundationDB/sql-layer-adapter-dbapi>`_ - this
  is an extension for the psycopg2 DBAPI, in order to provide nested result support.

* SQLAlchemy 0.9.2 or greater - The FoundationDB dialect relies on various API
  features that have been added throughout 0.8 and 0.9, and in particular
  requires 0.9.2 for proper support of a "grouped" foreign key.

The above prerequisites will be installed on-demand using the setup.py script:

.. sourcecode:: bash

    python setup.py install


Connecting
==========

SQLAlchemy-FoundationDB provides a SQLAlchemy dialect that's made available
to the :func:`sqlalchemy:sqlalchemy.create_engine` function like any other.   As fdb-sql
is based on psycopg2, the dialect here is also specific to that DBAPI::

    from sqlalchemy import create_engine

    engine = create_engine("foundationdb+psycopg2://@localhost:15432/")

The :class:`sqlalchemy:sqlalchemy.engine.Engine` above will produce connections when the
:meth:`sqlalchemy:sqlalchemy.engine.Engine.connect` method is called.

Nested Result Sets
==================

The dialect introduces a new type called :class:`.NestedResult`, the value of
which is a new SQLAlchemy :class:`~sqlalchemy:sqlalchemy.engine.ResultProxy` representing a nested result.
When invoking SQL as a string, the ``foundationdb_nested`` execution
option is used to alert the engine to switch into 'nested result' mode::

    with engine.begin() as conn:
        result = conn.execution_options(foundationdb_nested=True).execute(
                    "SELECT customer.id, "
                    "(SELECT order.id, order.data "
                    "FROM order "
                    "WHERE customer_id=customer.id) AS order "
                    "FROM customer")
        for row in result:
            print "customer id:", row['id']
            for order_row in row['order']:
                print "order id:", order_row['id']
                print "order data:", order_row['data']

DDL Integration
===============

At the core of FoundationDB SQL's nested result set capability is the
"grouped foreign key".   This is a FOREIGN KEY construct which includes
the "GROUPING" keyword.  To render this DDL, use the ``foundationdb_grouping=True``
keyword argument on either :class:`~sqlalchemy:sqlalchemy.schema.ForeignKeyConstraint`
or :class:`~sqlalchemy:sqlalchemy.schema.ForeignKey`::

    from sqlalchemy import MetaData, Table, Column, String, Integer, ForeignKey
    metadata = MetaData()
    customer = Table('customer',
        metadata,
        Column('id', Integer, primary_key=True),
        Column('name', String(20)),
    )

    order = Table('order',
        metadata,
        Column('id', Integer, primary_key=True),
        Column('customer_id', Integer,
                    ForeignKey('customer.id', foundationdb_grouping=True)),
        Column('order_info', String(20)),
    )

    metadata.create_all(conn)

Will emit DDL like::

    CREATE TABLE customer (
        id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
        name VARCHAR(20) NULL,
        PRIMARY KEY (id)
    )

    CREATE TABLE "order" (
        id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
        customer_id INTEGER NULL,
        order_info VARCHAR(20) NULL,
        PRIMARY KEY (id),
        GROUPING FOREIGN KEY(customer_id) REFERENCES customer (id)
    )

.. _core_nested_select:

Nested Select Constructs
========================

Moving up a level, the dialect introduces a new Core construct :class:`.nested`
which is an extension of SQLAlchemy's "scalar select" construct.   This construct is
a drop-in replacement for a standard :func:`~sqlalchemy.sql.expression.select`
subquery, and is a marker
intercepted by the FoundationDB dialect indicating that column and typing information about
a "nested result" should be carried over from statement to result set.
When using nested results with Core or ORM statement constructs, the
``foundationdb_nested`` execution option is implicitly set::

    from sqlalchemy import select
    from sqlalchemy_foundationdb import nested

    sub_stmt = nested([order]).where(order.c.customer_id
                                            == customer.c.id).label('o')
    stmt = select([sub_stmt]).where(customer.c.id == 1)

    result = conn.execute(stmt)

The above will produce SQL like the following::

    SELECT
        (SELECT "order".id, "order".customer_id,
                "order".order_info
        FROM "order" WHERE "order".customer_id =
        customer.id) AS o
    FROM customer WHERE customer.id = %(id_1)s

Within the result set, nested columns will be targetable not just by column name but
also by column object, and any SQLAlchemy-side type converters in place will take effect for these
columns::

        for row in result:
            print "customer id:", row[customer.c.id]
            for order_row in row['order']:
                print "order id:", order_row[order.c.id]
                print "order data:", order_row[order.c.data]

